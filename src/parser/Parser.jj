options {
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*; import ast.value.*; import ast.operations.*;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
     < Num: (["0"-"9"]) + >
  |  < PLUS : "+" >
  |  < MINUS : "-">
  |  < TIMES : "*">
  |  < DIV : "/">
  |  < LPAR : "(" >
  |  < RPAR : ")" >
  |  < EL: "\n" >
  |  < BOOL : ("true" | "false") >
  |  < EQREL : "==">
  |  < GT : ">">
  |  < GEQT : ">=">
  |  < LT : "<">
  |  < LEQT : "<=">
  |  < DIFF : "!=">
  |  < NOT : "!">
  |  < AND : "&&">
  |  < OR : "||">
  |
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

Exp Start():
{ Exp e; }
{
   e = logicOps() <EL>  { return e; }
}

Exp logicOps():
{Exp e1, e2;}
{
    e1 = BoolOps()
    [ <AND> e2 = logicOps() { e1 = new ASTAnd(e1,e2); }
    | <OR> e2 = logicOps() { e1 = new ASTOr(e1,e2); }]
    { return e1; }
}

Exp BoolOps():
{Exp e1, e2;}
{
    e1 = Expr()
    [ <EQREL> e2 = BoolOps() { e1 = new ASTEq(e1,e2); }
    | <GT> e2 = BoolOps() { e1 = new ASTGt(e1,e2); }
    | <GEQT> e2 = BoolOps() { e1 = new ASTGeq(e1,e2); }
    | <LT> e2 = BoolOps() { e1 = new ASTLt(e1,e2); }
    | <LEQT> e2 = BoolOps() { e1 = new ASTLeq(e1,e2); }
    | <DIFF> e2 = BoolOps() { e1 = new ASTDiff(e1,e2); }]
    { return e1; }

}


Exp Expr() :
{ Exp e1, e2; }
{
   e1 = Term() 
     [ <PLUS> e2 = Expr() { e1 = new ASTAdd(e1,e2); }
     | <MINUS> e2 = Expr() { e1 = new ASTSub(e1,e2); } ]
     { return e1; }
}

Exp Term() :
{ Exp e1, e2; }
{
     e1 = Fact()
     [ <TIMES> e2 = Term() { e1 = new ASTMult(e1,e2); }
     | <DIV> e2 = Term() { e1 = new ASTDiv(e1,e2); } ]
     { return e1; }
}

Exp Fact() :
{ Token x; Exp e;}
{
   x = <Num> {return new ASTInt(Integer.parseInt(x.image));}
 | x = <BOOL> { return new ASTBool(Boolean.parseBoolean(x.image)); }
 | ("-" e = Fact() { return new ASTNeg(e); })
 | <LPAR> e = Expr() <RPAR> { return e; }
}