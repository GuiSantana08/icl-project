options {
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*; import ast.operations.references.ASTLet;import ast.operations.references.ASTNew;import ast.operations.references.ASTRef;import ast.value.*; import ast.operations.arithmetic.*; import ast.operations.relational.*;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
     < Num: (["0"-"9"]) + >
  |  < PLUS : "+" >
  |  < MINUS : "-">
  |  < TIMES : "*">
  |  < DIV : "/">
  |  < LPAR : "(" >
  |  < RPAR : ")" >
  |  < EL: "\n" >
  |  < BOOL : ("true" | "false") >
  |  < EQREL : "==">
  |  < GT : ">">
  |  < GEQT : ">=">
  |  < LT : "<">
  |  < LEQT : "<=">
  |  < DIFF : "!=">
  |  < NOT : "~">
  |  < AND : "&&">
  |  < OR : "||">
  |  < LET : "let">
  |  < IN : "in">
  |  < NEW : "new">
  |  < DEREF : "!">
  |  < ATRIB : ":=">
  |  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

ASTNode Start():
{ ASTNode e; }
{
   e = logicOps() <EL>  { return e; }
}

ASTNode logicOps():
{ASTNode e1, e2;}
{
    e1 = BoolOps()
    [ <AND> e2 = logicOps() { e1 = new ASTAnd(e1,e2); }
    | <OR> e2 = logicOps() { e1 = new ASTOr(e1,e2); }]
    { return e1; }
}

ASTNode BoolOps():
{ASTNode e1, e2;}
{
    e1 = Expr()
    [ <EQREL> e2 = BoolOps() { e1 = new ASTEq(e1,e2); }
    | <GT> e2 = BoolOps() { e1 = new ASTGt(e1,e2); }
    | <GEQT> e2 = BoolOps() { e1 = new ASTGeq(e1,e2); }
    | <LT> e2 = BoolOps() { e1 = new ASTLt(e1,e2); }
    | <LEQT> e2 = BoolOps() { e1 = new ASTLeq(e1,e2); }
    | <DIFF> e2 = BoolOps() { e1 = new ASTDiff(e1,e2); }]
    { return e1; }

}


ASTNode Expr() :
{ ASTNode e1, e2; }
{
   e1 = Term() 
     [ <PLUS> e2 = Expr() { e1 = new ASTAdd(e1,e2); }
     | <MINUS> e2 = Expr() { e1 = new ASTSub(e1,e2); } ]
     { return e1; }
}

ASTNode Term() :
{ ASTNode e1, e2; }
{
     e1 = Fact()
     [ <TIMES> e2 = Term() { e1 = new ASTMult(e1,e2); }
     | <DIV> e2 = Term() { e1 = new ASTDiv(e1,e2); }
     | <ATRIB> e2 = Expr() { e1 = new ASTRef(e2); }]
     { return e1; }
}

ASTNode Let() :
{ ASTNode e1, e2; }
{
    <LPAR> e1 = Expr() <RPAR> <IN> e2 = Expr() { return new ASTLet(e1, e2); }
}

ASTNode Fact() :
{ Token x; ASTNode e;}
{
   x = <Num> {return new ASTInt(Integer.parseInt(x.image));}
 | x = <BOOL> { return new ASTBool(Boolean.parseBoolean(x.image)); }
 | <NOT> e = Fact() { return new ASTNot(e); }
 | ("-" e = Fact() { return new ASTNeg(e); })
 | <LPAR> e = Expr() <RPAR> { return e; }
 | <LET> Let()
 | <DEREF> e = Expr() { return new ASTRef(e); }
 | <NEW> e = Term() { return new ASTNew(e);}
}